name: Deploy All Services

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
          - development

env:
  NAMESPACE: rescuemesh
  DOCKER_USERNAME: kdbazizul

jobs:
  deploy-all:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'

    - name: Configure kubectl
      run: |
        mkdir -p $HOME/.kube
        echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > $HOME/.kube/config
        chmod 600 $HOME/.kube/config

    - name: Verify cluster connection
      run: |
        kubectl cluster-info
        kubectl get nodes

    - name: Deploy all services
      run: |
        # Deploy infrastructure
        echo "Deploying infrastructure..."
        kubectl apply -f k8s/namespace.yaml
        kubectl apply -f k8s/secrets/
        kubectl apply -f k8s/configmaps/
        kubectl apply -f k8s/storage/
        
        # Deploy databases and message queue
        echo "Deploying databases..."
        kubectl apply -f k8s/deployments/deployment-postgres*.yaml
        kubectl apply -f k8s/deployments/deployment-redis*.yaml
        kubectl apply -f k8s/deployments/deployment-rabbitmq.yaml
        
        # Wait for infrastructure
        echo "Waiting for infrastructure to be ready..."
        sleep 30
        
        # Deploy microservices
        echo "Deploying microservices..."
        kubectl set image deployment/user-service user-service=${{ env.DOCKER_USERNAME }}/rescuemesh-user-service:latest -n ${{ env.NAMESPACE }}
        kubectl set image deployment/skill-service skill-service=${{ env.DOCKER_USERNAME }}/rescuemesh-skill-service:latest -n ${{ env.NAMESPACE }}
        kubectl set image deployment/disaster-service disaster-service=${{ env.DOCKER_USERNAME }}/rescuemesh-disaster-service:latest -n ${{ env.NAMESPACE }}
        kubectl set image deployment/sos-service sos-service=${{ env.DOCKER_USERNAME }}/rescuemesh-sos-service:latest -n ${{ env.NAMESPACE }}
        kubectl set image deployment/matching-service matching-service=${{ env.DOCKER_USERNAME }}/rescuemesh-matching-service:latest -n ${{ env.NAMESPACE }}
        kubectl set image deployment/notification-service notification-service=${{ env.DOCKER_USERNAME }}/rescuemesh-notification-service:latest -n ${{ env.NAMESPACE }}
        
        # Deploy frontend
        echo "Deploying frontend..."
        kubectl set image deployment/frontend frontend=${{ env.DOCKER_USERNAME }}/rescuemesh-frontend:latest -n ${{ env.NAMESPACE }}
        
        # Deploy monitoring
        echo "Deploying monitoring..."
        kubectl apply -f k8s/monitoring/

    - name: Wait for all deployments
      run: |
        echo "Waiting for all services to be ready..."
        kubectl rollout status deployment/user-service -n ${{ env.NAMESPACE }} --timeout=5m
        kubectl rollout status deployment/skill-service -n ${{ env.NAMESPACE }} --timeout=5m
        kubectl rollout status deployment/disaster-service -n ${{ env.NAMESPACE }} --timeout=5m
        kubectl rollout status deployment/sos-service -n ${{ env.NAMESPACE }} --timeout=5m
        kubectl rollout status deployment/matching-service -n ${{ env.NAMESPACE }} --timeout=5m
        kubectl rollout status deployment/notification-service -n ${{ env.NAMESPACE }} --timeout=5m
        kubectl rollout status deployment/frontend -n ${{ env.NAMESPACE }} --timeout=5m

    - name: Verify all pods
      run: |
        kubectl get pods -n ${{ env.NAMESPACE }}
        
        # Count running pods
        RUNNING_PODS=$(kubectl get pods -n ${{ env.NAMESPACE }} --field-selector=status.phase=Running --no-headers | wc -l)
        echo "Running pods: $RUNNING_PODS"

    - name: Run health checks
      run: |
        sleep 15
        
        # Check health endpoint
        response=$(curl -sk https://api.villagers.live/health)
        echo "Health check response:"
        echo "$response"
        
        # Verify all services are healthy
        healthy=$(echo "$response" | grep -o '"status":"healthy"' | wc -l)
        if [ $healthy -lt 1 ]; then
          echo "Health check failed!"
          exit 1
        fi
        
        echo "âœ… All health checks passed!"

    - name: Deployment summary
      if: always()
      run: |
        echo "========================================="
        echo "Deployment Summary"
        echo "========================================="
        echo "Environment: ${{ github.event.inputs.environment }}"
        echo "Namespace: ${{ env.NAMESPACE }}"
        echo ""
        echo "Services:"
        kubectl get deployments -n ${{ env.NAMESPACE }}
        echo ""
        echo "Pods:"
        kubectl get pods -n ${{ env.NAMESPACE }}
        echo ""
        echo "Services (networking):"
        kubectl get services -n ${{ env.NAMESPACE }}
        echo ""
        echo "Ingress:"
        kubectl get ingress -n ${{ env.NAMESPACE }}
        echo "========================================="
